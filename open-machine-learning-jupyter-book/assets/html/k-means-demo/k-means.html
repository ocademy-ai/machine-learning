<html>

<head>
    <style type="text/css">
        A:link {
            text-decoration: none;
            font-weight: 500;
            color: #0000FF;
        }

        A:visited {
            text-decoration: none;
            font-weight: 500;
            color: #0000FF;
        }

        A:active {
            text-decoration: none;
            font-weight: 500;
            color: #0000FF;
        }

        A:hover {
            text-decoration: underline;
            font-weight: 500;
            color: #0000FF;
        }
    </style>
</head>

<body>
    <div style="vertical-aling:top; width:700px; margin:0px; padding:0px; border-collapse:collapse;">
        <span style="font-size: 28px;">
            K-means Clustering<br>
            <a style="font-size:18px">Interactive Demonstration</a>
        </span>
        <br />
        <script type="text/javascript" src="./d3.v2.min.js"></script>






        <p>"In data mining, k-means clustering is a method of cluster analysis which aims to partition n observations
            into k clusters in which each observation belongs to the cluster with the nearest mean."</p>

        <p>Use the 2D demonstration below to experiment with the standard Lloyd's algorithm to develop an intuition for
            the technique. You can try differently generated data, or select Manual to click in your own data points.
        </p>

        <p>The algorithm is quite simple. At first a random set of cluster centres is initiated. Points are then
            assigned to their nearest centre. Centres are adjusted to match the centre of all points assigned to them.
            The assignment and adjustment steps are repeated until the centres no longer move.</p>

        <p style="font-size:18px; font-weight:bold;">K-means Demonstration</p>

        <table style="width:700px; padding:0px;">
            <tr>
                <td style="width:500px; padding:0px;">
                    <div id='chart'></div>
                </td>
                <td style="width:200px: padding:0px; vertical-align:top;">
                    <table>
                        <tr>
                            <td colspan=2>
                                <u>Controls</u>
                            </td>
                        </tr>
                        <tr>
                            <td colspan=2>
                                <button onclick="button()">Iterate Algorithm</button><br>
                                <button onclick="initialise()">Re-Initialise</button><br>
                                Click and drag circles.
                            </td>
                        </tr>
                        <tr style="height:20px;"></tr>
                        <tr>
                            <td colspan=2>
                                <u>Data Generation</u>
                            </td>
                        </tr>
                        <tr>
                            <td style="align:right;">Method:</td>
                            <td style="alignt:left;">
                                <select id="method" onChange="changeState()">
                                    <option value="Random">Pure Random</option>
                                    <option value="Cluster">Random Clustered</option>
                                    <option value="Click">Manual</option>
                                </select>
                            </td>
                        </tr>
                        <tr>
                            <td style="alignt:right;">Points:</td>
                            <td style="alignt:left;"><input type="text" id="points" value=200></td>
                        </tr>
                        <tr>
                            <td style="alignt:right;">Clusters:</td>
                            <td style="alignt:left;"><input type="text" id="dataClusters" value=5></td>
                        </tr>
                        <tr>
                            <td colspan=2>
                                <input type="checkbox" id="clusterUniformity" checked> constant data cluster size
                            </td>
                        </tr>
                        <tr style="height:20px;"></tr>
                        <tr>
                            <td colspan=2>
                                <u>K-means</u>
                            </td>
                        </tr>
                        <tr>
                            <td style="alignt:right;">Clusters:</td>
                            <td style="alignt:left;"><input type="text" id="centres" value=5></td>
                        </tr>
                        <tr>
                            <td colspan=2>
                                <input type="checkbox" id="showHistory"> show history
                            </td>
                        </tr>
                    </table>
                </td>
            </tr>
        </table>

        <script type="text/javascript">

            // Set the initial UI state
            document.getElementById("method").value = "Random"
            document.getElementById("clusterUniformity").disabled = true;
            document.getElementById("dataClusters").disabled = true;
            document.getElementById("points").disabled = false;
            document.getElementById("showHistory").checked = false;

            function changeState() {
                if (document.getElementById("method").value == "Random") {
                    document.getElementById("clusterUniformity").disabled = true;
                    document.getElementById("dataClusters").disabled = true;
                    document.getElementById("points").disabled = false;
                }
                else if (document.getElementById("method").value == "Cluster") {
                    document.getElementById("clusterUniformity").disabled = false;
                    document.getElementById("dataClusters").disabled = false;
                    document.getElementById("points").disabled = false;
                }
                else if (document.getElementById("method").value == "Click") {
                    document.getElementById("clusterUniformity").disabled = true;
                    document.getElementById("dataClusters").disabled = true;
                    document.getElementById("points").disabled = true;
                }
            }

            var data = [];
            var centres = [];
            var vertices;

            var color = d3.scale.category10();

            var xPadding = 25;
            var yPadding = 5;

            var width = 500;
            var height = 500;

            var innerWidth = width - 2 * xPadding;
            var innerHeight = height - 2 * yPadding;

            var svg = d3.select("#chart")
                .append("svg")
                .attr("width", width)
                .attr("height", height)
                .append("g")
                .attr("transform", "translate(" + [xPadding, yPadding] + ")");

            var bounds = d3.geom.polygon([
                [0, 0],
                [0, height - 2 * yPadding],
                [width - 2 * xPadding, height - 2 * yPadding],
                [width - 2 * xPadding, 0]
            ]);

            var dragCentre = d3.behavior.drag()
                .origin(Object)
                .on("drag", function (d) {
                    var circle = d3.select(this);

                    circle
                        .attr("cx", d.x = Math.max(0, Math.min(width - 2 * xPadding, d3.event.x)))
                        .attr("cy", d.y = Math.max(0, Math.min(height - 2 * yPadding, d3.event.y)));

                    circle.datum().x = Math.max(0, Math.min(width - 2 * xPadding, d3.event.x));
                    circle.datum().y = Math.max(0, Math.min(height - 2 * yPadding, d3.event.y));

                })
                .on("dragend", function (d) {
                    assignment();
                    svg.selectAll("circle.data").transition().delay(1500).style("fill", function (d) { return color(d.cluster); });
                    drawVoronoi(1000, 1000);
                });

            var dragData = d3.behavior.drag()
                .origin(Object)
                .on("drag", function (d) {
                    var circle = d3.select(this);

                    circle
                        .attr("cx", d.x = Math.max(0, Math.min(width - 2 * xPadding, d3.event.x)))
                        .attr("cy", d.y = Math.max(0, Math.min(height - 2 * yPadding, d3.event.y)));

                    circle.datum().x = Math.max(0, Math.min(width - 2 * xPadding, d3.event.x));
                    circle.datum().y = Math.max(0, Math.min(height - 2 * yPadding, d3.event.y));

                })
                .on("dragend", function (d) {
                    assignment();
                    svg.selectAll("circle.data").transition().delay(1500).style("fill", function (d) { return color(d.cluster); });
                });


            initialise();


            function initialise() {
                svg.selectAll("circle.centres_history").remove();
                svg.selectAll("line.history").remove();
                svg.selectAll("rect.clickable").remove();

                generateCentres();

                if (document.getElementById("method").value == "Click") {
                    data = [];
                    svg.selectAll("circle.data").remove();
                    svg.append("rect")
                        .attr("x", 0)
                        .attr("y", 0)
                        .attr("width", innerWidth)
                        .attr("height", innerHeight)
                        .attr("class", "clickable")
                        .attr("fill", "#ffffff")
                        .style("fill-opacity", 0)
                        .on("click", function (d) {
                            var mouse = d3.svg.mouse(this);
                            var x = mouse[0];
                            var y = mouse[1];


                            data.push({ "x": x, "y": y, "cluster": -1 });

                            assignment(0);
                            drawDataPoints();
                        });
                } else {
                    initialiseData();
                }

                drawPoints();
                drawVoronoi(0, 1000);
                assignment();
            }

            function initialiseData() {
                var numDataPoints = document.getElementById('points').value;

                if (document.getElementById("method").value == "Random")
                    generateData(numDataPoints);

                if (document.getElementById("method").value == "Cluster")
                    generateClusteredData(numDataPoints, document.getElementById("dataClusters").value);
            }

            function generateData(numDataPoints, numCentres) {
                data = [];

                for (var i = 0; i < numDataPoints; i++)
                    data.push({ "x": Math.random() * (width - 2 * xPadding), "y": Math.random() * (height - 2 * yPadding), "cluster": 0 });
            }

            function generateClusteredData(numDataPoints, numClusters) {
                data = [];
                clusters = [];

                for (var i = 0; i < numClusters; i++) {
                    var x = (0.1 + 0.8 * Math.random()) * innerWidth;
                    var y = (0.1 + 0.8 * Math.random()) * innerHeight;
                    var maxR = Math.min(innerWidth - x, x, innerHeight - y, y);
                    var r = (0.5 + Math.random() / 2) * maxR;

                    clusters.push({ "x": x, "y": y, "r": r, "maxR": maxR });
                }

                if (document.getElementById("clusterUniformity").checked) {
                    var minMaxR = clusters[0].maxR;
                    for (var i = 1; i < numClusters; i++)
                        if (clusters[i].maxR < minMaxR)
                            minMaxR = clusters[i].maxR;

                    var maxOfR = clusters[0].r;
                    for (var i = 1; i < numClusters; i++)
                        if (clusters[i].r > maxOfR)
                            maxOfR = clusters[i].r;

                    var uniformR = Math.min(minMaxR, maxOfR);

                    for (var i = 0; i < numClusters; i++)
                        clusters[i].r = uniformR;
                }

                for (var i = 0; i < numClusters; i++) {
                    for (var j = i * Math.round(numDataPoints / numClusters); j < (i + 1) * Math.round(numDataPoints / numClusters); j++) {
                        var r = Math.random() * clusters[i].r;
                        var deg = Math.random() * 360;
                        var dx = r * Math.sin(deg / 180 * Math.PI);
                        var dy = r * Math.cos(deg / 180 * Math.PI);
                        data.push({ "x": clusters[i].x + dx, "y": clusters[i].y + dy, "cluster": 0 });
                    }
                }
            }

            function generateCentres() {
                centres = [];

                var numCentres = document.getElementById('centres').value;

                for (var i = 0; i < numCentres; i++)
                    centres.push({ "x": Math.random() * (width - 2 * xPadding), "y": Math.random() * (height - 2 * yPadding) });
            }

            function drawPoints() {
                svg.selectAll("circle.data").remove();

                drawDataPoints();

                svg.selectAll("circle.centres").remove();

                svg.selectAll("circle.centres").data(centres).enter()
                    .append("circle")
                    .attr("class", "centres")
                    .attr("cx", function (d) { return d.x; })
                    .attr("cy", function (d) { return d.y; })
                    .attr("r", 10)
                    .style("fill", "#000000")
                    .call(dragCentre);
            }

            function drawDataPoints() {
                svg.selectAll("circle.data").data(data).enter()
                    .append("circle")
                    .attr("class", "data")
                    .attr("cx", function (d) { return d.x; })
                    .attr("cy", function (d) { return d.y; })
                    .attr("r", 5)
                    .style("fill", function (d) { return color(d.cluster); })
                    .call(dragData);
            }

            function drawVoronoi(delay, duration) {
                svg.selectAll("path.voronoi").data([]).exit().transition().duration(1000).attr("stroke-opacity", 0).remove();

                var vertices = centres.map(function (d) {
                    return [d.x, d.y];
                });

                svg.selectAll("path.new")
                    .data(d3.geom.voronoi(vertices).map(function (cell) { return bounds.clip(cell); }))
                    .enter().append("path")
                    .attr("stroke-opacity", 0)
                    .attr("class", "voronoi")
                    .transition().delay(delay).duration(duration)
                    .attr("d", function (d) { return "M" + d.join("L") + "Z"; })
                    .attr("fill", "none")
                    .attr("stroke", "#999999")
                    .attr("stroke-opacity", 1);
            }

            var centresHistory = [];

            function button() {
                centresHistory.push(centres.clone());

                if (document.getElementById("showHistory").checked)
                    svg.selectAll("circles.new").data(centresHistory[centresHistory.length - 1]).enter()
                        .append("circle")
                        .attr("class", "centres_history")
                        .attr("cx", function (d) { return d.x; })
                        .attr("cy", function (d) { return d.y; })
                        .style("fill", "#000000")
                        .style("fill-opacity", 0.5);

                iterate();

                if (document.getElementById("showHistory").checked) {
                    var lineData = [];

                    for (var i = 0; i < centres.length; i++)
                        lineData.push({ "x1": centres[i].x, "y1": centres[i].y, "x2": centresHistory[centresHistory.length - 1][i].x, "y2": centresHistory[centresHistory.length - 1][i].y });

                    svg.selectAll("line.new").data(lineData).enter()
                        .append("line")
                        .attr("class", "history")
                        .attr("x1", function (d) { return d.x2; })
                        .attr("y1", function (d) { return d.y2; })
                        .attr("x2", function (d) { return d.x2; })
                        .attr("y2", function (d) { return d.y2; })
                        .style("stroke", "#cccccc")
                        .style("stroke-width", "1px");

                    svg.selectAll("circle.centres_history").transition().duration(2000)
                        .attr("r", 5);

                    svg.selectAll("line.history").transition().duration(2000)
                        .attr("x1", function (d) { return d.x1; })
                        .attr("y1", function (d) { return d.y1; });
                }

                svg.selectAll("circle.centres").transition().duration(2000)
                    .attr("cx", function (d) { return d.x; })
                    .attr("cy", function (d) { return d.y; });

                drawVoronoi(1000, 1000);
            };

            function assignment(delay) {
                for (var i = 0; i < data.length; i++) {
                    var assigned = 0;
                    var bestDistance = Math.sqrt(Math.pow(data[i].x - centres[0].x, 2) + Math.pow(data[i].y - centres[0].y, 2));

                    for (var j = 1; j < centres.length; j++) {
                        var distance = Math.sqrt(Math.pow(data[i].x - centres[j].x, 2) + Math.pow(data[i].y - centres[j].y, 2));
                        if (distance < bestDistance) {
                            assigned = j;
                            bestDistance = distance;
                        }
                    }

                    data[i].cluster = assigned;
                };

                svg.selectAll("circle.data").transition().delay(delay).style("fill", function (d) { return color(d.cluster); });
            }

            function iterate() {
                for (var j = 0; j < centres.length; j++) {
                    var totalX = 0;
                    var totalY = 0;
                    var countPoints = 0;

                    for (var i = 0; i < data.length; i++) {
                        if (data[i].cluster == j) {
                            totalX = totalX + data[i].x;
                            totalY = totalY + data[i].y;
                            countPoints += 1;
                        }
                    }

                    if (countPoints != 0) {
                        centres[j].x = totalX / countPoints;
                        centres[j].y = totalY / countPoints;
                    }
                }

                assignment(500);
            }

            // Thank you Brian Huisman
            // http://my.opera.com/GreyWyvern/blog/show.dml/1725165
            Object.prototype.clone = function () {
                var newObj = (this instanceof Array) ? [] : {};
                for (i in this) {
                    if (i == 'clone') continue;
                    if (this[i] && typeof this[i] == "object") {
                        newObj[i] = this[i].clone();
                    } else newObj[i] = this[i]
                } return newObj;
            };

        </script>









    </div>
</body>

</html>